a=int(input())  #영어 길이-무조건 짝수 4
b=input() #영어단어
#이게 매우 중요  ***********주의**
#1.일단 sorted로 정렬하는 것을 체크
#2.range(a)를 불러서 영어단어 길이만큼 인덱스 생성
#3.lambda의 key값을 이용
#4.먼저 b[x]를 통해서 작은 영어 단어 순으로 정렬
#--->그렇게하면 c는 작은 영어 단어 순의 인덱스 번호를 정렬 리스트로 만들어줌!
#5.그리고 같은 영어 단어 일때는 -x를 통해서 인덱스 번호가 큰 순으로 오도록 정렬
#--->왜냐하면 희원이가 이길 수 있다면 꼭 이기는 것으로 택해야하는데,
#    만약 인덱스 번호가 작은 순서대로 뽑는다면, 상근이는 뒤에서부터 번호를 뽑으므로
#    비기거나 상순이가 이길 수가 있기 때문에
#    인덱스가 큰 번호의 같은 단어를 희원이가 먼저 뽑을 수 있도록 해야함
c=sorted(range(a),key= lambda x:(b[x],-x))
san='' #상근이가 담을 단어 통
hu=''  #희원이가 담을 단어 통
d=[False]*a #False로 단어가 담겼는지 안담겼는지 확인
k1=a-1 #상근이는 뒤에서 담으므로 그에 대한 인덱스
k2=0   #희원이는 작은 단어부터 담으므로 c의 인덱스
for i in range(a//2):
    while d[k1]: #상근이가 먼저 단어를 뒤에서 담음
        k1-=1 #이때 만약 d[k1]이 True라면 이미 누가 그 단어를 사용했으므로 k1-=1
    san+=b[k1] #while반복을 통해서 d[k1]이 False임을 확인돼면 그 단어를 사용하고,
    d[k1]=True #True로 만들어줌

    while d[c[k2]]: #희원이가 담음 ************주의**
                    #-->여기선 c가 사전순으로 빠른 단어 인덱스를 가지고 있으므로,
                    #-->무조건 c[k2]를해서 d에게 인덱스를 알려줘야함!!!
        k2+=1 #마찬가지로  d[c[k2]]이 True라면 그 단어를 사용했으므로 k2+=1
    hu+=b[c[k2]] #while반복을 통해서 d[c[k2]]가 False임을 확인돼면 그 단어를 사용하고,
    d[c[k2]]=True #True로 만들어줌
            
if san>hu:#알파벳이 클 수록 크므로 sang이 더 크다면 hu가 사전 순으로 더 빠름.
    print('DA')
else:
    print('NE')
print(hu)
